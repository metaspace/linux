// SPDX-License-Identifier: GPL-2.0

//! Types for module parameters.
//!
//! C header: [`include/linux/moduleparam.h`](../../../include/linux/moduleparam.h)

use crate::prelude::*;

/// Types that can be used for module parameters.
///
/// Note that displaying the type in `sysfs` will fail if
/// [`core::str::from_utf8`] (as implemented through the [`core::fmt::Display`]
/// trait) writes more than [`PAGE_SIZE`] bytes (including an additional null
/// terminator).
///
/// [`PAGE_SIZE`]: `bindings::PAGE_SIZE`
pub trait ModuleParam: core::fmt::Display + core::marker::Sized {
    /// The `ModuleParam` will be used by the kernel module through this type.
    ///
    /// This may differ from `Self` if, for example, `Self` needs to track
    /// ownership without exposing it or allocate extra space for other possible
    /// parameter values. This is required to support string parameters in the
    /// future.
    type Value: ?Sized;

    /// Parse a parameter argument into the parameter value.
    ///
    /// `Err(_)` should be returned when parsing of the argument fails.
    ///
    /// Parameters passed at boot time will be set before [`kmalloc`] is
    /// available (even if the module is loaded at a later time). However, in
    /// this case, the argument buffer will be valid for the entire lifetime of
    /// the kernel. So implementations of this method which need to allocate
    /// should first check that the allocator is available (with
    /// [`crate::bindings::slab_is_available`]) and when it is not available
    /// provide an alternative implementation which doesn't allocate. In cases
    /// where the allocator is not available it is safe to save references to
    /// `arg` in `Self`, but in other cases a copy should be made.
    ///
    /// [`kmalloc`]: ../../../include/linux/slab.h
    fn try_from_param_arg(arg: &'static [u8]) -> Result<Self>;

    /// Get the current value of the parameter for use in the kernel module.
    ///
    /// This function should not be used directly. Instead use the wrapper
    /// `read` which will be generated by [`macros::module`].
    fn value(&self) -> &Self::Value;
}

/// Set the module parameter from a string.
///
/// Used to set the parameter value at kernel initialization, when loading
/// the module or when set through `sysfs`.
///
/// `param.arg` is a pointer to `*mut T` as set up by the [`module!`]
/// macro.
///
/// See `struct kernel_param_ops.set`.
///
/// # Safety
///
/// If `val` is non-null then it must point to a valid null-terminated
/// string. The `arg` field of `param` must be an instance of `T`.
///
/// # Invariants
///
/// Currently, we only support read-only parameters that are not readable
/// from `sysfs`. Thus, this function is only called at kernel
/// initialization time, or at module load time, and we have exclusive
/// access to the parameter for the duration of the function.
///
/// [`module!`]: macros::module
unsafe extern "C" fn set_param<T>(
    val: *const core::ffi::c_char,
    param: *const crate::bindings::kernel_param,
) -> core::ffi::c_int
where
    T: ModuleParam,
{
    // NOTE: If we start supporting arguments without values, val _is_ allowed
    // to be null here.
    assert!(!val.is_null());

    // SAFETY: By function safety requirement, val is non-null and
    // null-terminated. By C API contract, `val` is live and valid for reads
    // for the duration of this function.
    let arg = unsafe { CStr::from_char_ptr(val).as_bytes() };

    crate::error::from_result(|| {
        let new_value = T::try_from_param_arg(arg)?;

        // SAFETY: `param` is guaranteed to be valid by C API contract
        // and `arg` is guaranteed to point to an instance of `T`.
        let old_value = unsafe { (*param).__bindgen_anon_1.arg as *mut T };

        // SAFETY: `old_value` is valid for writes, as we have exclusive
        // access. `old_value` is pointing to an initialized static, an
        // so it is properly initialized.
        unsafe { core::ptr::replace(old_value, new_value) };
        Ok(0)
    })
}

/// Write a string representation of the current parameter value to `buf`.
///
/// # Safety
///
/// Must not be called.
///
/// # Note
///
/// This should not be called as we declare all parameters as read only.
#[allow(clippy::extra_unused_type_parameters)]
unsafe extern "C" fn get_param<T>(
    _buf: *mut core::ffi::c_char,
    _param: *const crate::bindings::kernel_param,
) -> core::ffi::c_int
where
    T: ModuleParam,
{
    unreachable!("Parameters are not readable");
}

/// Drop the parameter.
///
/// Called when unloading a module.
///
/// # Safety
///
/// The `arg` field of `param` must be an initialized instance of `Self`.
unsafe extern "C" fn free<T>(arg: *mut core::ffi::c_void)
where
    T: ModuleParam,
{
    // SAFETY: By function safety requirement, `arg` is an initialized
    // instance of `T`. By C API contract, `arg` will not be used after
    // this function returns.
    unsafe { core::ptr::drop_in_place(arg as *mut T) };
}

/// Trait for parsing integers.
///
/// Strings beginning with `0x`, `0o`, or `0b` are parsed as hex, octal, or
/// binary respectively. Strings beginning with `0` otherwise are parsed as
/// octal. Anything else is parsed as decimal. A leading `+` or `-` is also
/// permitted. Any string parsed by [`kstrtol()`] or [`kstrtoul()`] will be
/// successfully parsed.
///
/// [`kstrtol()`]: https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#c.kstrtol
/// [`kstrtoul()`]: https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#c.kstrtoul
trait ParseInt: Sized {
    fn from_str_radix(src: &str, radix: u32) -> Result<Self, core::num::ParseIntError>;

    // NOTE: Required because `checked_neg` is not provided by any trait.
    fn checked_neg(self) -> Option<Self>;

    fn from_str_unsigned(src: &str) -> Result<Self, core::num::ParseIntError> {
        let (radix, digits) = if let Some(n) = src.strip_prefix("0x") {
            (16, n)
        } else if let Some(n) = src.strip_prefix("0X") {
            (16, n)
        } else if let Some(n) = src.strip_prefix("0o") {
            (8, n)
        } else if let Some(n) = src.strip_prefix("0O") {
            (8, n)
        } else if let Some(n) = src.strip_prefix("0b") {
            (2, n)
        } else if let Some(n) = src.strip_prefix("0B") {
            (2, n)
        } else if src.starts_with('0') {
            (8, src)
        } else {
            (10, src)
        };
        Self::from_str_radix(digits, radix)
    }

    fn from_str(src: &str) -> Result<Self> {
        match src.bytes().next() {
            None => Err(EINVAL),
            Some(b'-') => Self::from_str_unsigned(&src[1..])
                .map_err(|_| EINVAL)?
                .checked_neg()
                .ok_or(EINVAL),
            Some(b'+') => Self::from_str_unsigned(&src[1..]).map_err(|_| EINVAL),
            Some(_) => Self::from_str_unsigned(src).map_err(|_| EINVAL),
        }
    }
}

macro_rules! impl_parse_int {
    ($ty:ident) => {
        impl ParseInt for $ty {
            fn from_str_radix(src: &str, radix: u32) -> Result<Self, core::num::ParseIntError> {
                $ty::from_str_radix(src, radix)
            }

            fn checked_neg(self) -> Option<Self> {
                self.checked_neg()
            }
        }
    };
}

impl_parse_int!(i8);
impl_parse_int!(u8);
impl_parse_int!(i16);
impl_parse_int!(u16);
impl_parse_int!(i32);
impl_parse_int!(u32);
impl_parse_int!(i64);
impl_parse_int!(u64);
impl_parse_int!(isize);
impl_parse_int!(usize);

macro_rules! impl_module_param {
    ($ty:ident) => {
        impl ModuleParam for $ty {
            type Value = $ty;

            fn try_from_param_arg(arg: &'static [u8]) -> Result<Self> {
                let utf8 = core::str::from_utf8(arg)?;
                <$ty as crate::module_param::ParseInt>::from_str(utf8)
            }

            #[inline(always)]
            fn value(&self) -> &Self::Value {
                self
            }
        }
    };
}

#[doc(hidden)]
#[macro_export]
/// Generate a static [`kernel_param_ops`](../../../include/linux/moduleparam.h) struct.
///
/// # Examples
///
/// ```ignore
/// make_param_ops!(
///     /// Documentation for new param ops.
///     PARAM_OPS_MYTYPE, // Name for the static.
///     MyType // A type which implements [`ModuleParam`].
/// );
/// ```
macro_rules! make_param_ops {
    ($ops:ident, $ty:ty) => {
        $crate::make_param_ops!(
            #[doc=""]
            $ops,
            $ty
        );
    };
    ($(#[$meta:meta])* $ops:ident, $ty:ty) => {
        $(#[$meta])*
        ///
        /// Static [`kernel_param_ops`](../../../include/linux/moduleparam.h)
        /// struct generated by [`make_param_ops`].
        pub static $ops: $crate::bindings::kernel_param_ops = $crate::bindings::kernel_param_ops {
            flags: 0,
            set: Some(set_param::<$ty>),
            get: Some(get_param::<$ty>),
            free: Some(free::<$ty>),
        };
    };
}

impl_module_param!(i8);
impl_module_param!(u8);
impl_module_param!(i16);
impl_module_param!(u16);
impl_module_param!(i32);
impl_module_param!(u32);
impl_module_param!(i64);
impl_module_param!(u64);
impl_module_param!(isize);
impl_module_param!(usize);

make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`i8`].
    PARAM_OPS_I8,
    i8
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`u8`].
    PARAM_OPS_U8,
    u8
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`i16`].
    PARAM_OPS_I16,
    i16
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`u16`].
    PARAM_OPS_U16,
    u16
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`i32`].
    PARAM_OPS_I32,
    i32
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`u32`].
    PARAM_OPS_U32,
    u32
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`i64`].
    PARAM_OPS_I64,
    i64
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`u64`].
    PARAM_OPS_U64,
    u64
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`isize`].
    PARAM_OPS_ISIZE,
    isize
);
make_param_ops!(
    /// Rust implementation of [`kernel_param_ops`](../../../include/linux/moduleparam.h)
    /// for [`usize`].
    PARAM_OPS_USIZE,
    usize
);
