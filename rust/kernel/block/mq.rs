// SPDX-License-Identifier: GPL-2.0

//! This module provides types for implementing block drivers that interface the
//! blk-mq subsystem.
//!
//! To implement a block device driver, a Rust module must do the following:
//!
//! - Implement [`Operations`] for a type `T`
//! - Create a [`TagSet<T>`]
//! - Create a [`GenDisk<T>`], passing in the `TagSet` reference
//! - Add the disk to the system by calling [`GenDisk::add`]
//!
//! The types available in this module that have direct C counterparts are:
//!
//! - The `TagSet` type that abstracts the C type `struct tag_set`.
//! - The `GenDisk` type that abstracts the C type `struct gendisk`.
//! - The `Request` type that abstracts the C type `struct request`.
//!
//! Many of the C types that this module abstracts allow a driver to carry
//! private data, either embedded in the stuct directly, or as a C `void*`. In
//! these abstractions, this data is typed. The types of the data is defined by
//! associated types in `Operations`, see [`Operations::RequestData`] for an
//! example.
//!
//! The kernel will interface with the block evice driver by calling the method
//! implementations of the `Operations` trait.
//!
//! IO requests are passed to the driver as [`Request`] references. The
//! `Request` type is a wrapper around the C `struct request`. The driver must
//! mark start of request processing by calling [`Request::start`] and end of
//! processing by calling one of the [`Request::end`], methods. Failure to do so
//! can lead to IO failures.
//!
//! The `TagSet` is responsible for creating and maintaining a mapping between
//! `Request`s and integer ids as well as carrying a pointer to the vtable
//! generated by `Operations`. This mapping is useful for associating
//! completions from hardware with the correct `Request` instance. The `TagSet`
//! determines the maximum queue depth by setting the number of `Request`
//! instances available to the driver, and it determines the number of queues to
//! instantiate for the driver. If possible, a driver should allocate one queue
//! per core, to keep queue data local to a core.
//!
//! One `TagSet` instance can be shared between multiple `GenDisk` instances.
//! This can be useful when implementing drivers where one piece of hardware
//! with one set of IO resources are represented to the user as multiple disks.
//!
//! One significant difference between block device drivers implemented with
//! these Rust abstractions and drivers implemented in C, is that the Rust
//! drivers have to own a reference count on the `Request` type when the IO is
//! in flight. This is to ensure that the C `struct request` instances backing
//! the Rust `Request` instances are live while the Rust driver holds a
//! reference to the `Request`. In addition, the conversion of an ineger tag to
//! a `Request` via the `TagSet` would not be sound without this bookkeeping.
//!
//! # âš  Note
//!
//! For Rust block device drivers, the point in time where a request
//! is freed and made available for recycling is usualy at the point in time
//! when the last `ARef<Request>` is dropped. For C drivers, this event usually
//! occurs when `bindings::blk_mq_end_request` is called.
//!
//! # Example
//!
//! ```rust
//! use kernel::{
//!     block::mq::*,
//!     new_mutex,
//!     prelude::*,
//!     sync::{Arc, Mutex},
//!     types::{ARef, ForeignOwnable},
//! };
//!
//! struct MyBlkDevice;
//!
//! #[vtable]
//! impl Operations for MyBlkDevice {
//!     type RequestData = ();
//!     type RequestDataInit = impl PinInit<()>;
//!     type QueueData = ();
//!     type HwData = ();
//!     type TagSetData = ();
//!
//!     fn new_request_data(
//!         _tagset_data: <Self::TagSetData as ForeignOwnable>::Borrowed<'_>,
//!     ) -> Self::RequestDataInit {
//!         kernel::init::zeroed()
//!     }
//!
//!     fn queue_rq(_hw_data: (), _queue_data: (), rq: ARef<Request<Self>>, _is_last: bool) -> Result {
//!         rq.start();
//!         rq.end_ok();
//!         Ok(())
//!     }
//!
//!     fn commit_rqs(
//!         _hw_data: <Self::HwData as ForeignOwnable>::Borrowed<'_>,
//!         _queue_data: <Self::QueueData as ForeignOwnable>::Borrowed<'_>,
//!     ) {
//!     }
//!
//!     fn complete(rq: &Request<Self>) {
//!         rq.end_ok();
//!     }
//!
//!     fn init_hctx(
//!         _tagset_data: <Self::TagSetData as ForeignOwnable>::Borrowed<'_>,
//!         _hctx_idx: u32,
//!     ) -> Result<Self::HwData> {
//!         Ok(())
//!     }
//! }
//!
//! let tagset: Arc<TagSet<MyBlkDevice>> = Arc::pin_init(TagSet::try_new(1, (), 256, 1))?;
//! let mut disk = GenDisk::try_new(tagset, ())?;
//! disk.set_name(format_args!("myblk"))?;
//! disk.set_capacity_sectors(4096);
//! disk.add()?;
//!
//! # Ok::<(), kernel::error::Error>(())
//! ```

mod gen_disk;
mod operations;
mod raw_writer;
mod request;
mod tag_set;

pub use gen_disk::GenDisk;
pub use operations::Operations;
pub use request::{Request, RequestDataRef};
pub use tag_set::TagSet;
